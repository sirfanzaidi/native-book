"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_book=self.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[140],{4762:function(n,e,i){i.r(e),i.d(e,{assets:function(){return a},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return r},toc:function(){return d}});var r=JSON.parse('{"id":"module-2-digital-twin/04-gazebo-fundamentals","title":"Chapter 4 - Gazebo Simulation Fundamentals","description":"Introduction","source":"@site/docs/02-module-2-digital-twin/01-gazebo-fundamentals.md","sourceDirName":"02-module-2-digital-twin","slug":"/module-2-digital-twin/04-gazebo-fundamentals","permalink":"/native-book/module-2-digital-twin/04-gazebo-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/native-book/native-book/tree/main/docs/02-module-2-digital-twin/01-gazebo-fundamentals.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"04-gazebo-fundamentals","title":"Chapter 4 - Gazebo Simulation Fundamentals","sidebar_label":"Chapter 4: Gazebo Basics"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Advanced Nodes","permalink":"/native-book/module-1-ros2/03-advanced-nodes"},"next":{"title":"Chapter 5: ROS 2 + Gazebo","permalink":"/native-book/module-2-digital-twin/05-ros2-gazebo-bridge"}}'),o=i(4848),t=i(8453);const s={id:"04-gazebo-fundamentals",title:"Chapter 4 - Gazebo Simulation Fundamentals",sidebar_label:"Chapter 4: Gazebo Basics"},l="Chapter 4: Gazebo Simulation Fundamentals",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Why Simulation?",id:"why-simulation",level:3},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Simulation vs Reality",id:"simulation-vs-reality",level:3},{value:"Understanding 3D Worlds",id:"understanding-3d-worlds",level:2},{value:"World Structure",id:"world-structure",level:3},{value:"Creating Your First Gazebo World",id:"creating-your-first-gazebo-world",level:2},{value:"Simple World with a Robot Arm",id:"simple-world-with-a-robot-arm",level:3},{value:"Expected Output",id:"expected-output",level:3},{value:"URDF: Robot Definition Format",id:"urdf-robot-definition-format",level:2},{value:"Common Joint Types",id:"common-joint-types",level:3},{value:"Running Gazebo with ROS 2",id:"running-gazebo-with-ros-2",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-4-gazebo-simulation-fundamentals",children:"Chapter 4: Gazebo Simulation Fundamentals"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(e.p,{children:["In Module 1, you learned how to control robots using ROS 2 nodes and messaging. But how do you ",(0,o.jsx)(e.strong,{children:"test and develop without a physical robot"}),"?"]}),"\n",(0,o.jsxs)(e.p,{children:["The answer is ",(0,o.jsx)(e.strong,{children:"simulation"}),". Gazebo is the open-source 3D robotics simulator that works seamlessly with ROS 2."]}),"\n",(0,o.jsx)(e.h3,{id:"why-simulation",children:"Why Simulation?"}),"\n",(0,o.jsx)(e.p,{children:"Simulating robots before deployment offers critical advantages:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cost"}),": No risk of damaging expensive hardware during development"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Speed"}),": Test algorithms 10x faster than real robots"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Iteration"}),": Try thousands of ideas without physical constraints"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Debugging"}),": Inspect internal robot state easily"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safety"}),": Test dangerous behaviors safely in simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Repeatability"}),": Identical test conditions every run"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Example"}),": Training a humanoid robot to walk takes weeks of simulation before running on hardware."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Source"}),": Gazebo Official Documentation. (2024). ",(0,o.jsx)(e.em,{children:"Why Gazebo?"}),". Retrieved from ",(0,o.jsx)(e.a,{href:"https://gazebosim.org/docs/",children:"https://gazebosim.org/docs/"})]}),"\n",(0,o.jsx)(e.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo is a ",(0,o.jsx)(e.strong,{children:"3D physics simulator"})," that models:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Physics"}),": Gravity, friction, collision detection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensors"}),": Cameras, LiDAR, IMU, distance sensors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Actuators"}),": Motors, joints, gripper forces"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Environment"}),": Terrain, obstacles, lighting"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamics"}),": Realistic robot movement and interaction"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"It integrates with ROS 2 via plugins, allowing the same ROS 2 code to work in simulation or on real robots."}),"\n",(0,o.jsx)(e.h3,{id:"simulation-vs-reality",children:"Simulation vs Reality"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"[ROS 2 Control Code]\n        \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  In Simulation    \u2502    In Reality\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  Gazebo Physics   \u2502    Physical Robot\n    \u2502  Virtual Robot    \u2502    Real Motors\n    \u2502  Fake Sensors     \u2502    Real Sensors\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2193\n    [Same ROS 2 Topics/Services]\n"})}),"\n",(0,o.jsx)(e.p,{children:"The beauty of ROS 2: your control code doesn't change whether running in Gazebo or on real hardware."}),"\n",(0,o.jsx)(e.h2,{id:"understanding-3d-worlds",children:"Understanding 3D Worlds"}),"\n",(0,o.jsxs)(e.p,{children:["A Gazebo ",(0,o.jsx)(e.strong,{children:"world"})," contains:"]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Models"}),": Robots, objects (URDF or SDF format)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Physics Engine"}),": Simulates gravity and collisions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensors"}),": Cameras, LiDAR that publish to ROS 2 topics"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Plugins"}),": Connect simulation to ROS 2"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"world-structure",children:"World Structure"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"World\n\u251c\u2500\u2500 Robot (URDF model)\n\u2502   \u251c\u2500\u2500 Links (body parts)\n\u2502   \u251c\u2500\u2500 Joints (connections)\n\u2502   \u251c\u2500\u2500 Sensors\n\u2502   \u2502   \u251c\u2500\u2500 Camera\n\u2502   \u2502   \u251c\u2500\u2500 LiDAR\n\u2502   \u2502   \u2514\u2500\u2500 IMU\n\u2502   \u2514\u2500\u2500 Actuators\n\u2502       \u251c\u2500\u2500 Motors\n\u2502       \u2514\u2500\u2500 Grippers\n\u251c\u2500\u2500 Ground Plane\n\u251c\u2500\u2500 Objects\n\u2502   \u251c\u2500\u2500 Cube\n\u2502   \u2514\u2500\u2500 Sphere\n\u2514\u2500\u2500 Physics\n    \u251c\u2500\u2500 Gravity\n    \u2514\u2500\u2500 Friction\n"})}),"\n",(0,o.jsx)(e.h2,{id:"creating-your-first-gazebo-world",children:"Creating Your First Gazebo World"}),"\n",(0,o.jsx)(e.h3,{id:"simple-world-with-a-robot-arm",children:"Simple World with a Robot Arm"}),"\n",(0,o.jsx)(e.p,{children:"We'll create a world with a basic robot arm in Gazebo:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nSimple Gazebo World Creation\nSpawns a robot arm in a Gazebo world\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.srv import SpawnEntity\nfrom geometry_msgs.msg import Pose\nimport os\n\n\nclass GazeboWorldCreator(Node):\n    def __init__(self):\n        super().__init__(\'gazebo_world_creator\')\n\n        # Wait for Gazebo to be ready\n        self.spawn_client = self.create_client(SpawnEntity, \'/spawn_entity\')\n        while not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for Gazebo spawn service...\')\n\n        self.get_logger().info(\'Gazebo ready!\')\n        self.create_robot_arm()\n\n    def create_robot_arm(self):\n        """Create and spawn a simple robot arm"""\n        # Simple robot arm URDF (2 links, 1 joint)\n        arm_urdf = \'\'\'<?xml version="1.0"?>\n        <robot name="simple_arm">\n            <link name="base">\n                <inertial>\n                    <mass value="1.0"/>\n                    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n                </inertial>\n                <visual>\n                    <geometry>\n                        <box size="0.1 0.1 0.1"/>\n                    </geometry>\n                </visual>\n            </link>\n\n            <link name="link1">\n                <inertial>\n                    <mass value="0.5"/>\n                    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n                </inertial>\n                <visual>\n                    <geometry>\n                        <cylinder length="0.3" radius="0.05"/>\n                    </geometry>\n                </visual>\n            </link>\n\n            <joint name="joint1" type="revolute">\n                <parent link="base"/>\n                <child link="link1"/>\n                <axis xyz="0 0 1"/>\n                <limit lower="0" upper="3.14" effort="10" velocity="1"/>\n            </joint>\n        </robot>\'\'\'\n\n        # Spawn the robot in Gazebo\n        request = SpawnEntity.Request()\n        request.name = \'simple_arm\'\n        request.xml = arm_urdf\n        request.initial_pose = Pose()\n        request.initial_pose.position.z = 0.5  # Above ground\n\n        future = self.spawn_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            self.get_logger().info(\'Robot arm spawned successfully!\')\n        else:\n            self.get_logger().error(\'Failed to spawn robot arm\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    world_creator = GazeboWorldCreator()\n    rclpy.spin(world_creator)\n    world_creator.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"What's happening"}),":"]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create a Gazebo spawn client"}),"\n",(0,o.jsx)(e.li,{children:"Define a robot arm in URDF format (XML)"}),"\n",(0,o.jsx)(e.li,{children:"Spawn the robot at position (0, 0, 0.5)"}),"\n",(0,o.jsx)(e.li,{children:"Log success/failure"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"expected-output",children:"Expected Output"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Terminal"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"[gazebo_world_creator] Waiting for Gazebo spawn service...\n[gazebo_world_creator] Waiting for Gazebo spawn service...\n[gazebo_world_creator] Gazebo ready!\n[gazebo_world_creator] Robot arm spawned successfully!\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Gazebo Window"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"3D view opens"}),"\n",(0,o.jsx)(e.li,{children:"Ground plane visible"}),"\n",(0,o.jsx)(e.li,{children:"Robot arm appears at center"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"urdf-robot-definition-format",children:"URDF: Robot Definition Format"}),"\n",(0,o.jsx)(e.p,{children:"URDF (Unified Robot Description Format) is XML that defines:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<robot name="my_robot">\n    \x3c!-- Links are rigid bodies --\x3e\n    <link name="base">...</link>\n    <link name="arm">...</link>\n\n    \x3c!-- Joints connect links --\x3e\n    <joint name="shoulder" type="revolute">\n        <parent link="base"/>\n        <child link="arm"/>\n        <axis xyz="0 0 1"/>\n        <limit lower="0" upper="3.14" effort="10" velocity="1"/>\n    </joint>\n</robot>\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Links"}),": Rigid bodies (have mass, geometry, visual shape)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joints"}),": Connections between links (revolute, prismatic, fixed)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Axes"}),": Rotation direction (x, y, or z)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Limits"}),": Joint angle ranges and torque limits"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"common-joint-types",children:"Common Joint Types"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Type"}),(0,o.jsx)(e.th,{children:"Motion"}),(0,o.jsx)(e.th,{children:"Example"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"revolute"}),(0,o.jsx)(e.td,{children:"Rotating"}),(0,o.jsx)(e.td,{children:"Shoulder, elbow"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"prismatic"}),(0,o.jsx)(e.td,{children:"Linear"}),(0,o.jsx)(e.td,{children:"Gripper fingers, slide"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"fixed"}),(0,o.jsx)(e.td,{children:"No motion"}),(0,o.jsx)(e.td,{children:"Attached tools"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"continuous"}),(0,o.jsx)(e.td,{children:"Unlimited rotation"}),(0,o.jsx)(e.td,{children:"Wheels"})]})]})]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Source"}),": ROS URDF Documentation. (2024). Retrieved from ",(0,o.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Introduction.html",children:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Introduction.html"})]}),"\n",(0,o.jsx)(e.h2,{id:"running-gazebo-with-ros-2",children:"Running Gazebo with ROS 2"}),"\n",(0,o.jsx)(e.p,{children:"To launch Gazebo and create worlds:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Start Gazebo with ROS 2 support\ngazebo --verbose world.sdf\n\n# In another terminal, spawn objects via ROS 2\nros2 service call /spawn_entity gazebo_msgs/SpawnEntity \\\n  \"{name: 'my_robot', xml: '$(cat robot.urdf)'}\"\n"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"In this chapter, you learned:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Why simulation"}),": Cost, speed, safety, repeatability"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"What Gazebo simulates"}),": Physics, sensors, actuators, environments"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"How to create worlds"}),": Using URDF robot definitions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Spawning robots"}),": Via ROS 2 service calls"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"URDF basics"}),": Links, joints, axes, limits"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Key Takeaway"}),": Gazebo lets you develop and test robot control code without expensive hardware."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Next steps"}),": In Chapter 5, we'll bridge Gazebo simulation with ROS 2 control, publishing sensor data and receiving commands."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"References"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Gazebo Official Documentation. (2024). ",(0,o.jsx)(e.em,{children:"Gazebo Sim"}),". Retrieved from ",(0,o.jsx)(e.a,{href:"https://gazebosim.org/docs/",children:"https://gazebosim.org/docs/"})]}),"\n",(0,o.jsxs)(e.li,{children:["ROS URDF Documentation. (2024). ",(0,o.jsx)(e.em,{children:"URDF Introduction"}),". Retrieved from ",(0,o.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Introduction.html",children:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Introduction.html"})]}),"\n",(0,o.jsxs)(e.li,{children:["Open Robotics. (2024). ",(0,o.jsx)(e.em,{children:"Gazebo Tutorials"}),". Retrieved from ",(0,o.jsx)(e.a,{href:"https://gazebosim.org/docs/garden/tutorials/",children:"https://gazebosim.org/docs/garden/tutorials/"})]}),"\n",(0,o.jsxs)(e.li,{children:["ROS 2 + Gazebo Integration. (2024). Retrieved from ",(0,o.jsx)(e.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkg_v11",children:"https://github.com/ros-simulation/gazebo_ros_pkg_v11"})]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453:function(n,e,i){i.d(e,{R:function(){return s},x:function(){return l}});var r=i(6540);const o={},t=r.createContext(o);function s(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);